# Shop

JPA 학습을 위해 간단한 쇼핑몰을 구현한 예제이다.

---

## 1. 엔티티를 API에서 직접 사용하지 않은 이유

엔티티는 JPA 영속성 관리를 위한 객체이며  
API 응답 모델로 사용하기에 적합하지 않다.

### 문제점
- 지연 로딩 프록시 객체 직렬화 문제
- Jackson, Hibernate 설정에 강하게 의존
- 양방향 연관관계로 인한 무한 루프 위험
- API 스펙 변경이 엔티티 구조 변경으로 이어짐

### 정리
- 엔티티는 내부 구현용으로만 사용
- API 응답은 DTO로 분리해서 설계

---

## 2. N+1 문제 분석

### 2.1 발생 상황

- 주문 목록 조회 API
- 연관관계
    - Order → Member (ManyToOne)
    - Order → Delivery (OneToOne)
- 모든 연관관계는 LAZY 로딩

---

### 2.2 실행된 쿼리 패턴

- 주문 조회 쿼리 1번
- 주문 수(N)만큼 Member 조회
- 주문 수(N)만큼 Delivery 조회

예시
- 주문 4건 조회 시  
  → 총 1 + 4 + 4 = 9번 쿼리 실행

---

### 2.3 원인

- JPQL은 한 번만 실행
- 연관 엔티티는 지연 로딩 상태
- 연관 객체 접근 시점에 추가 쿼리 발생

→ 조회 결과가 많아질수록 쿼리 수가 선형 증가

---

## 3. N+1 문제 해결

### 3.1 Fetch Join 적용

- JPQL에 fetch join 적용
- Order, Member, Delivery를 한 번에 조회

---

### 3.2 결과

- SQL 1번 실행
- 지연 로딩으로 인한 추가 쿼리 없음
- N+1 문제 해결

---

## 4. 쿼리방식 선택 권장순서

1. 엔티티를 DTO로 변환하는 방식 선택
    - 엔티티 직접 노출 금지
    - 리포지토리 재사용성 확보

2. 필요하면 fetch join으로 성능 최적화
    - 대부분의 N+1 문제는 해결됨

3. 그래도 부족하면 DTO로 직접 조회
    - JPQL `new` 명령어 사용
    - API 전용 쿼리 작성

4. 최후의 수단으로 네이티브 SQL / JDBC Template 사용
    - JPA로 해결하기 어려운 경우에만 제한적으로 사용

---

## 5. 정리

- 엔티티는 JPA 영속성 관리를 위한 객체이며, API 응답 모델로 사용하지 않는다.
- N+1 문제는 로딩 전략과 무관하게 발생하며, 연관 엔티티를 한 번에 조회하지 않을 때 나타난다.
- 지연 로딩(LAZY)은 기본 전략으로 사용한다.
- 즉시 로딩(EAGER)은 필요하지 않은 연관관계까지 항상 조회하므로 성능 문제를 유발하고, 튜닝을 어렵게 만든다.
- 조회 성능 문제는 로딩 전략 변경이 아니라 fetch join으로 해결한다.
- 대부분의 N+1 문제는 fetch join으로 해결 가능하다.
